;;;; Created on 2011-05-31 22:20:59
(in-package :todotree-model)
(defmethod task-has-children ((task task))
  (> (fetch 'task :count :conditions (list :parent-task-id (id task))) 0))
(defmethod get-child-tasks ((parent-id integer) user-id)
  (fetch 'task :all :conditions (list :parent-task-id parent-id :user-id user-id)))
(defmethod get-child-tasks ((task task) user-id)
  (get-child-tasks (id task) user-id))
(defmethod get-child-tasks ((nothing null) user-id)
  (declare (ignore nothing user-id)))
(defun sql-date+ (date amount unit)
  (when (eql unit :week)
    (setq unit :day)
    (setq amount (* amount 7)))
  (clsql:date+ date (make-instance 'clsql:duration unit amount)))
(defun sql-date- (date amount unit)
  (when (eql unit :week)
    (setq unit :day)
    (setq amount (* amount 7)))
  (clsql:date- date (make-instance 'clsql:duration unit amount)))
(defun get-period-dates (period)
  (case period
    (:today
      (values "day" (clsql:get-date)))
    (:tomorrow
      (values "day" (sql-date+ (clsql:get-date) 1 :day)))
    (:week
      (values "week" (sql-trunc-week (clsql:get-date))))
    (:next-week
      (values "week" (sql-trunc-week (sql-date+ (clsql:get-date) 1 :week))))
    (:month
      (values "month" (sql-trunc-month (clsql:get-date))))
    (:next-month
      (values "month" (sql-trunc-month (sql-date+ (clsql:get-date) 1 :month))))
    (otherwise (values nil nil))))
(defun sql-trunc-week (date)
  (sql-date- date (- (clsql:date-dow date) 1) :day ))
(defun sql-trunc-month (date)
  (sql-date- date (- (third (multiple-value-list (clsql:date-ymd date))) 1) :day))
(defun filter-tasks* (date user-id &key segment)
  (if segment
      (fetch 'task :all :conditions (list :user-id user-id) :where (clsql:sql-= (clsql:sql-function "date_trunc" segment (clsql:sql-expression :attribute "date_due")) date))
      (fetch 'task :all :conditions (list :date date :user-id user-id))))
(defmethod filter-tasks ((time clsql:wall-time) user-id &key segment)
  (filter-tasks* time user-id :segment segment))
(defmethod filter-tasks ((date clsql:date) user-id &key (segment "day"))
  (filter-tasks* date user-id :segment segment))
(defmethod filter-tasks ((period keyword) user-id &key segment)
  (declare (ignore segment))
  (multiple-value-bind (segment date) (get-period-dates period)
    (filter-tasks* date user-id :segment segment)))
(defmethod toggle-task ((task task) &optional checked)
  (let ((completed (if checked (if (string-equal checked "true") "t" "f") "t")))
    (update-task (id task) :completed (string-equal completed "t"))
    (clsql:update-records 'task :av-pairs (list (list 'completed completed)) :where (clsql:sql-= (clsql:sql-expression :attribute 'parent-task-id) (id task)))))
(defmethod toggle-task ((id integer) &optional checked)
  (let ((task (fetch 'task id)))
    (when task (toggle-task task checked))))
(defmethod toggle-task ((id string) &optional checked)
  (let ((task (fetch 'task id)))
    (when task (toggle-task task checked))))
(defmethod add-child-task ((task task) name &key priority description started active date-due color)
  (add-task name (task-user-id task) priority description started active date-due (id task) nil color))
(defmethod add-child-task ((task-id integer) name &key priority description started active date-due color)
  (add-child-task (fetch 'task task-id) name :priority priority :description description :started started :active active :date-due date-due :color color))
(defmethod add-child-task ((task-id string) name &key priority description started active date-due color)
  (let ((priority (if (and priority (not (string-equal "" priority))) 
                      (intern (string-upcase priority) :keyword) 
                      :normal))) 
    (add-child-task (fetch 'task task-id) name :priority priority :description description :started started :active active :date-due date-due :color color)))


